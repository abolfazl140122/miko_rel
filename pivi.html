<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>چت شخصی - همیار</title>
    <style>
        /* --- FONT & GLOBAL STYLES --- */
        @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;500;700&display=swap');
        
        :root {
            --primary-color: #007bff;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --body-bg: #f0f2f5;
            --chat-bg: #e5ddd5;
            --header-bg: #ffffff;
            --border-color: #dee2e6;
            --sent-bg: #dcf8c6;
            --received-bg: #ffffff;
            --text-primary: #333;
            --text-secondary: #6c757d;
            --modal-overlay-bg: rgba(0, 0, 0, 0.5);
            --shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Vazirmatn', sans-serif;
            margin: 0;
            background-color: var(--body-bg);
            color: var(--text-primary);
            -webkit-user-select: none;
            user-select: none;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* --- LAYOUT & CONTAINERS --- */
        .app-container {
            width: 100%;
            height: 100%;
            max-width: 450px;
            background-color: white;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        /* --- CHAT HEADER --- */
        .chat-header {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--header-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .chat-header .back-btn { background: none; border: none; font-size: 1.8em; cursor: pointer; color: var(--text-secondary); padding: 5px; transform: scaleX(-1); }
        .chat-header .partner-info { display: flex; align-items: center; cursor: pointer; gap: 12px; }
        .chat-header .partner-info img { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; }
        .chat-header .partner-info h2 { font-size: 1.1em; font-weight: 500; margin: 0; }
        .chat-header .options-btn { background: none; border: none; font-size: 1.8em; cursor: pointer; color: var(--text-secondary); padding: 5px; }

        /* --- MESSAGES AREA --- */
        main {
            flex-grow: 1;
            position: relative;
            background-color: var(--chat-bg);
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse; /* Important for showing new messages at the bottom */
            padding: 15px;
        }
        #messages-area {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .message {
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 12px;
            word-wrap: break-word;
            position: relative;
            box-shadow: var(--shadow);
            line-height: 1.5;
        }
        .message.sent { background-color: var(--sent-bg); align-self: flex-end; border-bottom-right-radius: 4px; }
        .message.received { background-color: var(--received-bg); align-self: flex-start; border-bottom-left-radius: 4px; }
        .message .meta { font-size: 0.75em; color: var(--text-secondary); margin-top: 5px; text-align: left; direction: ltr; }
        .message.deleted .text { font-style: italic; color: var(--text-secondary); }
        .message .meta .edited-indicator { margin-left: 5px; }

        /* --- MESSAGE FORM --- */
        #message-form {
            display: flex;
            padding: 10px;
            border-top: 1px solid var(--border-color);
            background: var(--header-bg);
            flex-shrink: 0;
            gap: 10px;
        }
        #message-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-family: 'Vazirmatn';
            font-size: 1em;
            transition: border-color 0.2s;
        }
        #message-input:focus { outline: none; border-color: var(--primary-color); }
        #message-input:disabled { background-color: #e9ecef; cursor: not-allowed; }
        #message-form button {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            font-size: 1.6em;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        #message-form button:hover { background-color: #0056b3; }
        
        /* --- MODALS & CONTEXT MENUS --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: var(--modal-overlay-bg);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 12px;
            width: 90%;
            max-width: 350px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.2);
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .modal-content h3 { margin-top: 0; font-weight: 500; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 15px; }
        .modal-content button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--body-bg);
            cursor: pointer;
            font-family: 'Vazirmatn';
            font-size: 1em;
            transition: background-color 0.2s;
            text-align: right;
            padding-right: 15px;
        }
        .modal-content button:hover { background-color: #e2e6ea; }
        .modal-content button.danger { border-color: transparent; background-color: var(--danger-color); color: white; }
        .modal-content button.danger:hover { background-color: #c82333; }
        .modal-content button.success { border-color: transparent; background-color: var(--success-color); color: white; }
        .modal-content button.success:hover { background-color: #218838; }
        .modal-content textarea { width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 10px; font-family: 'Vazirmatn'; resize: vertical; font-size: 1em; }
    </style>
</head>
<body>

    <div class="app-container">
        <!-- HEADER -->
        <header class="chat-header">
            <button class="back-btn" onclick="window.location.href='safe_asli.html'">➤</button>
            <div class="partner-info" id="partner-info">
                <img id="partner-avatar" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Avatar">
                <h2 id="partner-name">...</h2>
            </div>
            <button class="options-btn" id="options-btn">⋮</button>
        </header>

        <!-- MAIN CHAT AREA -->
        <main>
            <div id="messages-area">
                <!-- Messages will be loaded here dynamically -->
            </div>
        </main>

        <!-- MESSAGE INPUT FORM -->
        <form id="message-form">
            <input type="text" id="message-input" placeholder="پیام خود را بنویسید..." autocomplete="off">
            <button type="submit" aria-label="Send">⬆️</button>
        </form>
    </div>

    <!-- MODALS (Hidden by default) -->
    <div class="modal-overlay" id="options-modal">
        <div class="modal-content">
            <h3>گزینه‌ها</h3>
            <button id="toggle-block-btn">مسدود کردن کاربر</button>
            <button data-close>انصراف</button>
        </div>
    </div>

    <div class="modal-overlay" id="edit-modal">
        <div class="modal-content">
            <h3>ویرایش پیام</h3>
            <textarea id="edit-input" rows="4" placeholder="متن جدید..."></textarea>
            <button id="save-edit-btn" class="success">ذخیره تغییرات</button>
            <button data-close>انصراف</button>
        </div>
    </div>
    
    <div class="modal-overlay" id="context-menu-modal">
        <div class="modal-content">
            <h3>عملیات پیام</h3>
            <button id="context-edit-btn">ویرایش</button>
            <button id="context-delete-btn" class="danger">حذف</button>
            <button data-close>انصراف</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const PROXY_URL = 'https://miko.freehost.io/firebase_proxy.php';

        // --- DOM Elements ---
        const partnerNameEl = document.getElementById('partner-name');
        const partnerAvatarEl = document.getElementById('partner-avatar');
        const messagesArea = document.getElementById('messages-area');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message-input');
        
        // Modals & Buttons
        const optionsBtn = document.getElementById('options-btn');
        const optionsModal = document.getElementById('options-modal');
        const editModal = document.getElementById('edit-modal');
        const contextMenuModal = document.getElementById('context-menu-modal');
        const toggleBlockBtn = document.getElementById('toggle-block-btn');

        // --- App State ---
        let currentUser = null;
        let clientToken = null;
        let chatPartner = null;
        let chatId = null;
        let isPartnerBlocked = false;
        let messagePollingInterval = null;
        let contextMessageId = null;

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', async () => {
            const storedUser = localStorage.getItem('currentUser');
            clientToken = localStorage.getItem('clientToken');

            if (!storedUser || !clientToken) {
                alert("اطلاعات کاربری یافت نشد. لطفاً دوباره وارد شوید.");
                window.location.href = 'login.html';
                return;
            }
            currentUser = JSON.parse(storedUser);

            const partnerUsername = new URLSearchParams(window.location.search).get('with');
            if (!partnerUsername) {
                alert('کاربر هدف برای چت مشخص نشده است.');
                history.back();
                return;
            }
            
            await initializeApp(partnerUsername);
        });

        async function initializeApp(partnerUsername) {
            try {
                // Fetch full data for both users to ensure we have the latest info (like block list)
                const [partnerData, currentUserFullData] = await Promise.all([
                    fetchUserByUsername(partnerUsername),
                    apiRequest(`?path=users/${currentUser.uid}`, 'GET')
                ]);
                
                if (!partnerData) {
                    alert('کاربر مورد نظر یافت نشد.');
                    history.back();
                    return;
                }
                chatPartner = partnerData;
                // Merge basic stored data with full, fresh data from the database
                currentUser = { ...currentUser, ...currentUserFullData };

                // Generate a consistent, alphabetical chat ID
                chatId = [currentUser.username, chatPartner.username].sort().join('__');
                
                // Check initial block status based on the full user data
                isPartnerBlocked = currentUser.blockedUsers && currentUser.blockedUsers[chatPartner.uid] && currentUser.blockedUsers[chatPartner.uid].isBlocked === true;
                
                setupUI();
                setupEventListeners();
                
                await loadMessages();
                // Start polling for new messages
                if (messagePollingInterval) clearInterval(messagePollingInterval);
                messagePollingInterval = setInterval(loadMessages, 3000); 
                
            } catch (error) {
                console.error("Initialization Error:", error);
                alert(`خطا در بارگذاری اطلاعات چت: ${error.message}`);
            }
        }
        
        // --- UI SETUP & UPDATES ---
        function setupUI() {
            partnerNameEl.textContent = chatPartner.displayName;
            partnerAvatarEl.src = `https://i.pravatar.cc/80?u=${chatPartner.username}`;
            document.title = `چت با ${chatPartner.displayName}`;
            updateBlockStatusUI();
        }

        function updateBlockStatusUI() {
            if (isPartnerBlocked) {
                toggleBlockBtn.textContent = 'رفع انسداد کاربر';
                toggleBlockBtn.classList.remove('danger');
                toggleBlockBtn.classList.add('success');
                messageInput.disabled = true;
                messageInput.placeholder = "شما این کاربر را مسدود کرده‌اید.";
            } else {
                toggleBlockBtn.textContent = 'مسدود کردن کاربر';
                toggleBlockBtn.classList.add('danger');
                toggleBlockBtn.classList.remove('success');
                messageInput.disabled = false;
                messageInput.placeholder = "پیام خود را بنویسید...";
            }
        }

        function setupEventListeners() {
            messageForm.addEventListener('submit', handleSendMessage);
            optionsBtn.addEventListener('click', () => optionsModal.style.display = 'flex');
            toggleBlockBtn.addEventListener('click', handleToggleBlock);
            
            // Generic modal close listeners for background click or close button
            document.querySelectorAll('.modal-overlay').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal || e.target.hasAttribute('data-close')) {
                        modal.style.display = 'none';
                    }
                });
            });
            document.querySelectorAll('.modal-content button[data-close]').forEach(btn => {
                btn.addEventListener('click', () => btn.closest('.modal-overlay').style.display = 'none');
            });

            // Message context menu action listeners
            document.getElementById('context-edit-btn').addEventListener('click', showEditModal);
            document.getElementById('context-delete-btn').addEventListener('click', handleDeleteMessage);
            document.getElementById('save-edit-btn').addEventListener('click', saveEditedMessage);
        }

        // --- DATA FETCHING & API ---
        async function fetchUserByUsername(username) {
             const response = await apiRequest(`?path=users&orderBy="username"&equalTo="${username}"`, 'GET');
             if (response && Object.keys(response).length > 0) {
                 return Object.values(response)[0]; // Return the first user found
             }
             return null;
        }

        async function loadMessages() {
            if (!chatId) return;
            const messagesData = await apiRequest(`?path=pivi_chats/${chatId}/messages`, 'GET');
            
            messagesArea.innerHTML = ''; // Clear before re-rendering
            if (messagesData) {
                const sortedMessages = Object.entries(messagesData).sort((a, b) => a[1].timestamp.localeCompare(b[1].timestamp));
                sortedMessages.forEach(([msgId, msg]) => renderMessage(msgId, msg));
            }
        }

        function renderMessage(msgId, msg) {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message ' + (msg.senderId === currentUser.uid ? 'sent' : 'received');
            msgDiv.dataset.id = msgId;

            let textContent = msg.deleted ? 'این پیام حذف شده است' : (msg.text || '');
            if (msg.deleted) msgDiv.classList.add('deleted');

            const editedIndicator = msg.edited ? '<span class="edited-indicator">(ویرایش شده)</span>' : '';
            const time = new Date(msg.timestamp).toLocaleTimeString('fa-IR', { hour: '2-digit', minute: '2-digit' });

            msgDiv.innerHTML = `
                <div class="text">${textContent.replace(/\n/g, '<br>')}</div>
                <div class="meta">${time} ${editedIndicator}</div>
            `;
            
            // Add context menu (right-click or long-press) for sent, non-deleted messages
            if (msg.senderId === currentUser.uid && !msg.deleted) {
                msgDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    contextMessageId = msgId;
                    contextMenuModal.style.display = 'flex';
                });
            }
            messagesArea.appendChild(msgDiv);
        }

        // --- CORE ACTIONS ---
        async function handleSendMessage(e) {
            e.preventDefault();
            const text = messageInput.value.trim();
            if (!text || isPartnerBlocked) return;
            
            const message = { 
                senderId: currentUser.uid, 
                text: text, 
                timestamp: new Date().toISOString()
            };
            messageInput.value = '';

            try {
                // Ensure chat members are set (idempotent PUT operation)
                await apiRequest(`?path=pivi_chats/${chatId}/members`, 'PUT', { [currentUser.uid]: true, [chatPartner.uid]: true });
                // Post the new message
                await apiRequest(`?path=pivi_chats/${chatId}/messages`, 'POST', message);
                await loadMessages(); // Refresh immediately after sending
            } catch(error) {
                console.error("Send message failed:", error);
                alert('خطا در ارسال پیام.');
                messageInput.value = text; // Restore text on failure
            }
        }

        function showEditModal() {
            contextMenuModal.style.display = 'none';
            const messageDiv = document.querySelector(`.message[data-id="${contextMessageId}"] .text`);
            if (messageDiv) {
                document.getElementById('edit-input').value = messageDiv.textContent.trim();
                editModal.style.display = 'flex';
            }
        }

        async function saveEditedMessage() {
            const newText = document.getElementById('edit-input').value.trim();
            if (!newText || !contextMessageId) return;
            
            await apiRequest(`?path=pivi_chats/${chatId}/messages/${contextMessageId}`, 'PATCH', { text: newText, edited: true });
            
            editModal.style.display = 'none';
            await loadMessages();
        }

        async function handleDeleteMessage() {
            contextMenuModal.style.display = 'none';
            if (confirm('آیا از حذف این پیام مطمئن هستید؟ این عمل برگشت‌ناپذیر است.')) {
                // Soft delete: update the message instead of removing it entirely
                await apiRequest(`?path=pivi_chats/${chatId}/messages/${contextMessageId}`, 'PATCH', { text: 'این پیام حذف شده است', deleted: true });
                await loadMessages();
            }
        }

        async function handleToggleBlock() {
            const path = `?path=users/${currentUser.uid}/blockedUsers/${chatPartner.uid}`;
            const action = isPartnerBlocked ? 'unblock' : 'block';

            try {
                if (action === 'unblock') {
                    await apiRequest(path, 'DELETE');
                    alert(`${chatPartner.displayName} با موفقیت از انسداد خارج شد.`);
                    isPartnerBlocked = false;
                } else {
                    // Storing as an object `{isBlocked: true}` ensures the request body is a JSON object,
                    // which is required for our proxy to embed the auth_override_uid.
                    await apiRequest(path, 'PUT', { isBlocked: true });
                    alert(`${chatPartner.displayName} با موفقیت مسدود شد.`);
                    isPartnerBlocked = true;
                }
                updateBlockStatusUI();
            } catch (error) {
                console.error("Block/Unblock failed:", error);
                alert('عملیات ناموفق بود. لطفاً دوباره تلاش کنید.');
            } finally {
                optionsModal.style.display = 'none';
            }
        }

        // --- API REQUEST HELPER ---
        async function apiRequest(url, method, body = null) {
            const headers = { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${clientToken}`
            };
            const options = { method, headers };

            // For methods that can have a body, embed the current user's UID for server-side validation.
            if (method === 'POST' || method === 'PUT' || method === 'PATCH') {
                let requestBody = body || {};
                // Ensure body is an object to carry the override UID.
                if (typeof requestBody !== 'object' || requestBody === null) {
                     // This case is avoided by our block/unblock logic change.
                     console.warn("Request body is not an object, UID override might not work.", requestBody);
                }
                requestBody.auth_override_uid = currentUser.uid;
                options.body = JSON.stringify(requestBody);
            }
            
            try {
                const response = await fetch(`${PROXY_URL}${url}`, options);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'خطای ناشناخته در سرور' }));
                    console.error(`API Error on ${url}:`, response.status, errorData);
                    throw new Error(errorData.error || `خطای HTTP: ${response.status}`);
                }
                // Handle responses with no content (like DELETE or successful PUT)
                if (response.status === 204 || response.headers.get('content-length') === '0') {
                    return null;
                }
                return response.json();
            } catch (error) {
                 console.error("Fetch API request failed:", error);
                 // Re-throw to be caught by the calling function
                 throw error;
            }
        }
    </script>
</body>
</html>
